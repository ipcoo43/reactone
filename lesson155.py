# 알고리즘은 어떤 문제 풀기 위한 절차와 방법
# 주어진 입력을 출력으로 만드는 과정을 구체적이고 명료하게 표현 하는 것

# [ 알고리즘의 중요 포인트 ]
# 문제 : 알고리즘이 있으려면 반드시 문제가 필요하다.
#   문제 : 1부터 n까지 연속한 숫자의 합 구하기 
# 입력 : 알고리즘은 주어진 입력을 출력으로 만드는 과정
#   입력 : 1부터 n까지 - n
# 출력 : n =10 이면 1부터 10까지의 합 55
#   출력 : 55 

# [ 구체적이고 명료한 계산 과정 ]
# 평소 우리가 생각하는 방식 ( 1부터 10까지 합 구하기 )
# 1 더하기 2를 계산한 결과인 3을 머릿속에 기억한다.
# 기억해 둔 3에 다음 숫자 3을 더해 6을 기억한다.
# 기억해 둔 6에 다음 숫자 4을 더해 10을 기억한다.
# 기억해 둔 10에 다음 숫자 5를 더해 15를 기억한다.
# 6에서 9까지 같은 과정을 반복 한다
# 기억해 둔 45에 다음 숫자 10을 더해 55를 기억한다
# 10까지 다 더했으므로 마지막에 기억된 55를 답으로 제시한다.
# 1+2 = 3(기억)
# 3(기억)+3 = 6(기억)
# 6(기억)+4 = 10(기억)
# 45(기억)+10 = 55(답)
# 위와 같이 어떤 문제를 본 순간 무의식적으로 알고리즘을 만들고
# 만들어진 알고리즘을 수행하는 컴퓨터와 같은 일을 뇌가 하고 있다.
# 다만 사람은 지능과 유통성을 발휘해 굉장히 구체적인 알고리즘을 
# 종이에 적지 않고도 머릿속으로 적당히 계산법을 찾아내 문제를 풀 수 있다.
# 컴퓨터는 주어진 명령을 기계적으로 수행하는 장치이므로
# 기계가 알아 들을 수 있는 명료하고 구체적인 알고리즘이 있어야 풀 수 있다.

# [ 1부터 n까지의 합을 구하는 알고리즘 ]
# 문제 : 1부터 n까지 연속한 숫자의 합 구하기
# 입력 : n
# 알고리즘 : 1부터 n까지의 합을 구하는 절차
# 출력 : 1부터 n까지의 합
# n = 10
# 입력 : 10
# 알고리즘 : 1부터 10까지의 합을 구하는 절차
# 출력 : 55

# [ 1부터 n까지 연속한 숫자의 합 알고리즘]
# 합을 기록할 변수 s를 만들고 0을 저장한다.
# 변수 i를 만들어 1부터 n까지의 숫자를 1씩 증가시키며 반복 한다.
# <반복 블록> 기존의 s에 i를 더하여 얻은 값을 다시 s에 저장한다.
# 반복이 끝났을 때 s에 저장된 값이 결과 값이 된다.

# 알고리즘을 하나의 함수로 만들어 
# 입력은 인자로 전달하고
# 출력은 함수의 결과값(return 값)으로 만드면
# 입력 - 알고리즘 - 출력을 수행하는 과저이라는 직관적으로 이해 된다.

# [ 1부터 n까지 연속한 숫자의 합 구하기 ]
# 입력 : n
# 출력 : 1부터 n까지 숫자를 더한 값

def sum_one(n):
    s = 0 # 합을 계산한 변수
    for i in range(1, n+1): # 1부터 n까지 반복(n+1은 제외)
        s = s + i # 기존의 s에 i를 더하여 얻은 값을 다시 s에 저장한다.
    return s
print(sum_one(10)) # 55

# [ 알고리즘 분석 ]
# 첫 번째 방법 : 숫자를 차례로 더하는 방법
# 두 번째 방법 : 가우스 어렸을 적 방법
# 1 + 10 = 11
# 2 + 9  = 11
# 3 + 8  = 11
# 4 + 7  = 11
# 5 + 6  = 11
# 11 * 5 = 55
# 공식 : n(n+1)/2

def sum_two(n):
    return n*(n+1)//2 # // 정수 나눈셈 ( 나눗셈 몫 )
print(sum_two(10))

# 첫 번째 방법 : n이 커질수혹 덧셈을 훨씬 더 많이 반복 해야 한다.
# 두 번째 방법 : n값의 크기와 관계없이 덧셈, 곱셈, 나눗셈을 한번만 하면 된다.
# 두 번째 방법을 사용하는 것이 효율적이다.

# [ 입력 크기와 계산 횟수 ]
# 입력 크기가 수행 성능에 영향을 미침
# 1부터 n까지의 합 : n의 크기가 입력 크기
# 첫 번째 방법 : s에 0을 넣고 차례로 1부터 n까지 더하는 방법, 덧셈 10번
# 두 번째 방법 : 입력 크기 n이 아무리 큰 수라도 덧셈 한번, 곱셈 한번, 나눗셈 한번
# 첫 번째 방법 : 덧셈 n번
# 두 번째 방법 : 덧셈, 곱셈, 나누셈 한번 (총 세번)
# 입력 크기가 작을 때는 두 방법에 큰 차이는 없다
# 입력 크기가 커질수록 엄천난 차이가 발생 한다.
# n=1000이 되면 첫 번째는 1000번 해야 한다. 두 번째는 세 번이다.
# 알고리즘 분석에서는 입력 크기 n에 대해서 따져 보는 것이 중요하다.

# [ 대문자 O 표기법 : 계산 복잡도 표현 ]
# 계산 복잡도(Complexit) : 계산이 얼마나 복잡하지 나나내는 정도
# 대문자 O표기법 : 빅오 표기법
# 첫 번째 방법 : 입력 크기 n에 대해 덧셈을 n번 해야 한다
# O(n) : 필요한 계산 횟수가 입력 크기에 정비례 할 때
# O(n) 은 립력 크기와의 관계로 표현 한다.
# 두 번째 방법 : 입력 크기 n과 문관하게 사칙 연산 세번 O(1)
# 입력 크기가 커져도 계산 시간이 더 늘어나지 않는 다면 O(1)
# 빅오 표기법은 입력 크기 n과 필요한 계산 횟수와의 관계
# O(n) : 필요한 계산 횟수가 입력 크기 n과 비례 할 때
# O(1) : 필요한 계산 횟수가 입력 크기 n과 무관 할 
# 알고리즘의 계산 복잡도 : 시간 복잡도(time complexity), 공간 복잡도(space complexity)
# 시간 복잡도 : 수행하는 데 얼마나 오랜 시간이 걸리는 지 분석
# 공간 복잡도 : 수행하는 데 얼마나 많은 공간(메모리/기억장소) 필요한지 분석
