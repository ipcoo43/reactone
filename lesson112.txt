[ 집합 구현하기 ]

< 중복된 원소 제거하기 >
- 집합은 구별 가능한 것들의 모임이다.
a=[1,2,3,1] # a변수에 리스트 객체가 연결되었는데 1이 중복되어 있다.
            # 그래서 중복되지 않은 새로운 리스트를 생성하고자 한다
new_a = [] # 새로운 변수 new_a을 공집합으로 만들어 새로운 원소들을 저장할 것이다.
for i in a :         # a list에 있는 원소를 i라하고
  if i not in new_a: # i가 new_a에 없다면
    new_a.append(i)  # new_a에 i를 추가하라
print(new_a)         # 그리고, new_a를 출력하라
# 그러면 1,2,3이 출력 될 것이다.

[ 합집합 구현하기 ]
a=[1,2,3] # a변수에 리스트 객체를 연결하고
b=[4,5,6] # b변수에 리스트 객체를 연결하고
c=a+b     # a변수의 리스트 개체와 b변수의 리스트 개체를 더하여 c변수에 연결하고
print(c)  # c를 출력하라
# 그러면 1,2,3,4,5,6이 출력 될 것 이다.
# 하지만
a=[1,2,3] # a변수에 리스트 객체를 연결하고
b=[3,4,5] # b변수에 리스트 객체를 연결하고 
c=a+b     # a변수의 리스트 개체와 b변수의 리스트 개체를 더하여 c변수에 연결하고
print(c)  # c를 출력하라
# 그러면 1,2,3,3,4,5가 출력되었는데 3이 2개나 들어 있어 합집합이 될 수 없다
# 이때 [1,2,3,4,5]라는 합집합을 어떻게 구 할 것인가?
# 해결 방법은 a,b의 원소를 비교하여 서로 공통 요소를 찾으면 된다.
# a의 1,2,3이 b에 3,4,5에 있나 살펴보는 과정이 필요하다.

c=[]             # 합집합을 우선 공집합을 만들어 놓고
for i in a:      # a에 속한 모든 원소 i에 대해서 순서대로 반복하고
  if i not in b: # i가 b에 속하지 않는다면
    c.append(i)  # 합집합 c에 i를 추가하여라
c = c + b        # 합집합 c에 b를 더하라
c.sort()         # 합집합 c를 올림차순 정렬하라
print(c)         # 합집합 c를 출력하라
# 그러면 1,2,3,4,5의 합집합이 출력 될 것 이다.

c=[]  # 합집합을 우선 공집합으로 만들어 놓고
for i in a:       # a의 원소 i에 대해
  if i not in c:  # i가 c에 없다면
    c.append(i)   # c에 그 원소 i를 추가하라
for i in b:       # b의 원소 i에 대해
  if i not in c:  # i가 c에 없다면
     c.append(i)  # c에 그 원소 i를 추가하라
c.sort()          # c를 오름차순 정렬하라
print(c)          # c를 출력하라
# 그러면 1,2,3,4,5를 구할 것이다.

a=['apple','melon','orange']
b=['chicken','pig','cow']
c=[]             # c를 공집합으로 만들어 놓고
for i in a:      # a의 원소 i에 대해
  if i not in b: # i가 b에 없다면
    c.append(i)  # c에 i를 추가하라
c = c + b        # c에 c를 b를 더하라
c.sort()         # c를 오름차순 정렬하라
print(c)         # c를 출력하라
# ['apple', 'chicken', 'cow', 'melon', 'orange', 'pig']

# 중복 원소를 만들어 구하자
b[1]='melon'  # b원소 2번째 'pig'를 'melon'으로 교체
b=['chicken', 'melon', 'cow']
c=[] # c를 공집합으로 만들어 놓고
for i in a:      # a의 원소 i에 대해
  if i not in b: # i가 b에 없다면
    c.append(i)  # c에 i를 추가하라
c=c+a
c.sort()
print(c)
# ['apple', 'chicken', 'cow', 'melon', 'orange']

[ 교집합 구하기 ]
- 교집합은 두 집합의 공통된 원소로 이루어진 집합
a=[1,2,3]
b=[3,4,5]
c=[]  # 교집합을 우선 공집합으로 만들어 놓고
for i in a:     # a의 원소 i에 대해
  if i in b:    # i가 b에 속한다면
    c.append(i) # 교집합 c에 i를 추가하라
print(c)        # [3]

[ 차집합 구하기 ]
# c=a-b
# a의 요소중 b에 속하지 않는 집합을 a의 b에 차집합이라고 한다
# a를 c라는 집합으로 복사해놓고
# b 원소중에 c에 속하면 remove(b의 원소)
a=[1,2,3]
b=[3,4,5]
c=a+[]          # c는 a와 똑같은 리스트가 되게 복사
for i in b:     # b의 원소 i에 대해
  if i in a:    # i가 a에 속한다면
    c.remove(i) # c에서 i를 제거하라
print(c)        # [1,2]

a=[1,2,3]
b=[3,4,5]
c=a             # c는 a와 똑같은 리스트가 복사
for i in b:     # b의 원소 i에 대해
  if i in a     # i가 a에 속한다면
    c.remove(i) # c에서 i를 제거하라
print(c)        # [1,2]
print(a)        # [1,2]

a=[1,2,3]
b=[3,4,5]
c=a.copy()
for i in b:     # b의 원소 i에 대해
  if i in a:    # i가 a에 속한다면
    c.remove(i) # c에서 i를 제거하라
print(c)        # [1,2]
print(a)        # [1,2,3]

[ 여집합 구하기 ( 차집합과 동일 ) ]
a의 여집합은 전체 집합중 a에 속하지 않는 모든 요소들
여집합은 전체에서 a를 뺀 차집하과 같다
u=[0,1,2,3,4,5,6,7,8,9,0]
a=[1,3,5,7,9]
rest = u + []      # 여집합 rest를 전체집합 u와 똑같이 만들고
for i in a:        # a의 원소 i에 대해서
  if i in u:       # i가 u에 속한다면
    rest.remove(i) # rest에서 i를 제거하라
print(rest)        # [0, 2, 4, 6, 8, 0]

[ 생각할 거리 ]
a=[1,3,4,5,6]
b=[2,4,6,3,0]

for i in a:     # a의 원소 i에 대해서
  if i in b:    # i가 b에 속한다면
    a.remove(i) # a에서 i를 제거하라
c = a + b
print(d)        # [1, 4, 5, 2, 4, 6, 3, 0]

# 예상 c = [1,3,4,5,6,2,0]가 아니라 엉뚱한 결과가 나왔다.
# 그 이유는 a.remove(i)가 list a를 변형시켜서 이다.
# 1,3,4,5,6 순서로 계산되는 것이 아니라 순서가 바뀌게 된다.
# for는 1에 대해서 b에 없다는 것을 확인하다.
# 그 다음, 3에 대해서 b에도 3이 있는 것을 확인하죠
# 그러면 a에서 3을 제거 한다.
# 그 다음 4를 조사하는 것이 아니라 5를 조사 합니다.
# for 문은 a의 index 0,1,2,3,4의 요소들인 1,3,4,5,6순으로 실행시키는데
# index가 1인 3을 실행할때, a에서 3을 빼라는 명령이 오면 
# a는 1,4,5,6이 되고 이 새로운 a의 index 2번째 값은 4가 아니라 5가 됩니다.
# 따라서 5번에 대해서 for문이 실행되는 것이고, 4에대해서는 remove 명령이 수행 되지 않음

# for문을 수행 할 때 절대 원소를 추가하거나 제거하면 안된다.

